<h2>合并DC原理</h2>

<p>在第6章，我们学习了DrawCall（DC）是什么。现在让我们深入了解一个重要的优化技巧：<strong>合并DrawCall</strong>。这是游戏性能优化中最常用的手段之一。</p>

<div class="key-point">
  <h4>💡 核心概念</h4>
  <p>合并 DC 的核心不是"把网格拼大"，而是<strong>减少状态切换</strong>。</p>
  <p>常见的优化路径是：<strong>先减少材质种类</strong>（图集/统一 shader），<strong>再考虑合批或 instancing</strong>。</p>
</div>

<h3>为什么要合并DC？</h3>

<p>每次 DrawCall 都会带来 CPU 侧的提交开销、状态切换开销和驱动开销。</p>

<blockquote>
<p>想象你在网上购物：如果你买10件东西，分10个订单下单，快递员要跑10趟；但如果合并成1个订单，快递员只需要跑1趟。合并DC就是这个道理——<strong>减少"跑腿"的次数</strong>。</p>
</blockquote>

<div class="life-analogy">
  <h4>🎨 古老的智慧：日本神社的印刷术</h4>
  <figure style="text-align: center; margin: 1rem 0;">
    <img src="assets/images/jap.png" alt="日本传统印刷画" style="max-width: 100%; border-radius: 8px;">
    <figcaption style="color: var(--color-ink-muted); font-size: 0.9em; margin-top: 0.5rem;">日本传统木版印刷</figcaption>
  </figure>
  <p>这是日本的一种传统印刷画。神社的和尚会给人们发放祈福的卡片。</p>
  <p>想象一下，如果每个图案都要单独盖一次章，那和尚们不得累死？一张卡片上有几十个小图案，每个都盖一次，一天下来手都要废了。</p>
  <p>聪明的和尚发现了一个技巧：<strong>把同一种颜色的图案刻在同一块木板上</strong>。这样印一张卡片只需要盖四次章（四种颜色），而不是几十次。</p>
  <p>和尚们很快就下班了。</p>
  <p><strong>这就是合并DC的古老智慧！</strong>同一材质（颜色）的东西放在一起处理，大大减少了"盖章"（DrawCall）的次数。</p>
</div>

<pre><code class="language-javascript">// 未优化：每个物体一个DrawCall
function renderWithoutBatching(objects) {
  for (const obj of objects) {
    bindMaterial(obj.material);
    bindMesh(obj.mesh);
    drawCall();  // 每个物体都要调用一次
  }
}
// 100个物体 = 100次DrawCall

// 优化后：相同材质的物体合并
function renderWithBatching(objects) {
  const batches = groupByMaterial(objects);
  
  for (const [material, meshes] of batches) {
    bindMaterial(material);
    const combinedMesh = combineMeshes(meshes);
    bindMesh(combinedMesh);
    drawCall();  // 相同材质只需要一次
  }
}
// 100个物体，10种材质 = 10次DrawCall</code></pre>

<h3>合并的前提条件</h3>

<p>要合并 DrawCall，需要满足一些条件：</p>

<ul>
  <li><strong>相同的 Shader</strong>：使用同一个着色器程序</li>
  <li><strong>相同的渲染状态</strong>：混合模式、深度测试等设置相同</li>
  <li><strong>静态物体</strong>：位置不会改变（对于静态合批）</li>
</ul>

<p>注意：材质参数的差异（比如不同颜色、不同纹理）有时也能合并，只要使用同一个 Shader，通过不同的 uniform 或 instance data 来区分即可。这就是 GPU Instancing 的原理。</p>

<blockquote>
<p>这就像是拼车：只要目的地方向相同（Shader 相同）、走同一条路（渲染状态相同），即使每个人要去的具体地点不同（材质参数不同），也可以拼在一起。</p>
</blockquote>

<h3>静态合批 vs 动态合批</h3>

<p>合批有两种主要方式：</p>

<h4>静态合批（Static Batching）</h4>

<pre><code class="language-javascript">// 静态合批：在游戏启动时预先合并
class StaticBatcher {
  constructor() {
    this.batches = new Map();
  }
  
  // 预处理阶段：合并所有静态物体
  preprocess(staticObjects) {
    // 按材质分组
    for (const obj of staticObjects) {
      const key = obj.material.id;
      if (!this.batches.has(key)) {
        this.batches.set(key, []);
      }
      this.batches.get(key).push(obj);
    }
    
    // 合并每组的网格
    for (const [materialId, objects] of this.batches) {
      const combinedVertices = [];
      const combinedIndices = [];
      
      for (const obj of objects) {
        // 将物体的顶点变换到世界空间
        const worldVertices = transformVertices(
          obj.mesh.vertices, 
          obj.worldMatrix
        );
        
        // 合并顶点和索引
        const indexOffset = combinedVertices.length;
        combinedVertices.push(...worldVertices);
        combinedIndices.push(
          ...obj.mesh.indices.map(i => i + indexOffset)
        );
      }
      
      // 创建合并后的网格
      this.batches.set(materialId, {
        mesh: createMesh(combinedVertices, combinedIndices),
        material: objects[0].material
      });
    }
  }
}</code></pre>

<p>静态合批的<strong>优点</strong>：运行时开销极小</p>
<p>静态合批的<strong>缺点</strong>：占用更多内存，物体不能移动</p>

<h4>动态合批（Dynamic Batching）</h4>

<pre><code class="language-javascript">// 动态合批：每帧实时合并
class DynamicBatcher {
  batchAndRender(objects) {
    // 按材质分组
    const groups = groupByMaterial(objects);
    
    for (const [material, groupObjects] of groups) {
      // 检查是否值得合批
      // （太大的网格合批反而更慢）
      if (this.shouldBatch(groupObjects)) {
        this.renderBatched(material, groupObjects);
      } else {
        this.renderIndividually(material, groupObjects);
      }
    }
  }
  
  shouldBatch(objects) {
    const totalVertices = objects.reduce(
      (sum, obj) => sum + obj.mesh.vertexCount, 0
    );
    // 顶点数太多就不合批
    return totalVertices < 900;
  }
  
  renderBatched(material, objects) {
    bindMaterial(material);
    
    // 实时合并顶点数据
    const batchedData = this.combineOnTheFly(objects);
    uploadToGPU(batchedData);
    
    drawCall();
  }
}</code></pre>

<p>动态合批的<strong>优点</strong>：支持移动的物体</p>
<p>动态合批的<strong>缺点</strong>：每帧都要计算，有CPU开销</p>

<h3>GPU Instancing：更高效的方式</h3>

<p>当你有大量相同网格但不同位置的物体时（比如森林里的树），GPU Instancing是更好的选择：</p>

<pre><code class="language-javascript">// GPU Instancing：一次DrawCall绘制多个实例
function renderWithInstancing(mesh, material, transforms) {
  bindMaterial(material);
  bindMesh(mesh);
  
  // 上传所有实例的变换矩阵
  uploadInstanceData(transforms);
  
  // 一次调用绘制所有实例
  drawInstanced(transforms.length);
}

// 1000棵树 = 1次DrawCall！</code></pre>

<blockquote>
<p>GPU Instancing就像是复印机：你只需要提供一个模板（网格）和一份清单（变换矩阵），GPU就能快速"复印"出所有副本。</p>
</blockquote>

<h3>实际优化建议</h3>

<p>按优先级排序：</p>

<ol>
  <li><strong>减少材质种类</strong>：这是最重要的一步！
    <ul>
      <li>使用图集（Atlas）：把多张小纹理合并成一张大纹理</li>
      <li>统一 Shader：尽量让相似物体使用相同的着色器</li>
    </ul>
  </li>
  <li><strong>合理规划渲染状态</strong>：减少混合模式、深度测试等状态的切换</li>
  <li><strong>静态合批</strong>：不会移动的物体标记为静态，预先合并</li>
  <li><strong>GPU Instancing</strong>：大量相同网格的物体用 instancing</li>
  <li><strong>使用LOD</strong>：远处的物体用简化模型，减少顶点数</li>
</ol>

<blockquote>
<p>记住：先减少状态切换的次数，再考虑怎么合并网格。顺序很重要！</p>
</blockquote>

<h3>小结</h3>

<p>在这一章中，我们学到了：</p>

<ol>
  <li>DrawCall有开销，合并可以提升性能</li>
  <li>相同材质的物体可以合并绘制</li>
  <li>静态合批适合不移动的物体</li>
  <li>动态合批适合小型移动物体</li>
  <li>GPU Instancing适合大量相同网格的物体</li>
</ol>

<p>掌握合并DC的技巧，能让你的游戏运行得更流畅。下一章，我们将学习<strong>深度纹理</strong>——一个在很多高级效果中都会用到的重要概念！</p>
